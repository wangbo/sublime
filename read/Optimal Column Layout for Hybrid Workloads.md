# 核心目标
优化混合下的效率，混合负载主要指的是读和写

# 主要思路

1 了解设计空间，也就是权衡点，不同场景的不同解决方案
2 引入描述访问模式的频率模型；引入代价模型;
3 考虑鲁棒性

感觉就是通过分析查询模式，根据代价进行的动态优化，同时保证程序的稳定性

# 列存布局设计

所谓更新和global buffer有啥关系

列存设计的权衡点
	数据组织方式
		写入顺序
		排序
		分区

	更新策略
		in-place
		out-of-place
		hybird

	Buffering
		none
		global
		per-partition

水平分区和垂直分区
	这个没看懂

分区个数可调节来平衡读写代价
	这里有个重要的概念，所谓的分区是没有范围重叠的分区

	感觉上这里分区的概念更像是要做范围裁剪

	分区的代价
		分区越多，写代价越高，但是读代价越低
		反之亦然

	分区的类型
		分区较多，适用于读场景，对于选择性好的列，因为只需要读部分数据
		分区较少，适合更新插入删除的场景 （这个其实没太理解，分区多少和更新的关系）
		equi-width分区，不适用于访问有热点的分区（那感觉是不是通过修改并发也可以）
		narrow分区，点查和范围查比较合适

## Ghost Values
	对于更新，插入，删除操作来说，如果不要求数据是连续的话，那么移动数据的移动操作是可以省去的
	引入ghost value主要是通过降低写入时的代价，但是需要额外的空间

## 工作负载驱动决策
	范围分区和ghost value使得系统可以实现可调节的性能

	通过调节分区数，平衡读写代价
	通过增加buffer空间，可以降低写代价，但是读代价会增加；（这个应该主要是针对更新场景说的）

	通过代价模型，进行决策，找出最佳的方案

# 访问分区字段

	点查
	范围查询
		对于分区排过序且没有范围覆盖的来说，这个查找流程没啥好说的

	insert

		1 先找到该值对应的分区
		2 在最后一个分区的结尾加一个空的slot
		3 从最后一个分区开始，移动当前分区的第一个元素到下一个分区的头部
		4 这样目标分区的结尾相当于多了一个空的slot
		5 把要插入的值写入目标分区结尾


		他这个insert感觉更像是原地插入, doris目前是追加的应该
		其次我感觉这里分区的概念更像是一个连续数组内的多个区域，不是传统理解上的分区概念
		因为如果是按文件划分的话，应该直接追加到文件结尾就行了
		（应该是因为这主要是针对主内存数据库优化的）

	delete
		和insert比较类似，删除指定分区指定位置的值，然后把分区末尾的数值向前移动
		最后在最后一个分区的末尾会哟一个空的slot

	update
		delete +  insert

	这不会是面向内存数据库的设计吧

# 探索数据集，分区方案和工作负载的关系

## 分区方案
		最小单位是个block
		分区可以有如下方式
		1 每个分区有相等的block数
		2 每个分区的block数不等

## 频率模型
		定义直方图，block被哪个操作访问

		定义操作
			pq,点查询
			rs，范围查询的起始
			re，范围查询的结束
			sc，全block扫描
			de，为每个block定义delete操作
			in,insert
			udf,udb 更新相关
			utf，ufb

		更新直方图
			根据对block的访问更新，对定义的操作进行更新，比如做+1

		如何使用这个模型
			对所有block有所分区的访问操作进行统计，可以分为10种，主要是统计访问次数
			访问频率结合分区个数，可以得出一个代价模型

			这个更像是一种滞后的调节



## 代价函数(如何计算代价)
		对于主内存数据库来说，分区的边界是逻辑上的，因此可以在运行时动态调整

		先说明分区边界的意义，应该是可以直接用于过滤数据的
		一个分区包含多个block

		这里的关键是，如何把代价问题转换成数学问题

		定义数据的读取方式
			RR，随机读
			RW，随机写
			SR，顺序读
			SW，顺序写
		
		范围查询模型



