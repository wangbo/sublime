# 问题
1 linux系统中的调度开销如何评估？是否有具体的数值？

# 进程分类

1 交互式进程
	不需要一直处于活动状态，但是用到时需要能够做到快速响应
	比如文本编辑器啥的

2 批处理进程
	对响应和延迟要求不高，不与用户直接交互，但是对cpu占用的时间比较长

3 实时进程
	音视频应用，需要支持处于活动状态，且不能被低优先级的任务抢占
	需要很短的响应时间，且响应时间的变化很小

# 多任务系统的分类
1 非抢占式多任务，进程自动挂起(yielding)
2 抢占式多任务，当一个进程进入TASK_RUNNING状态，内核检查它的动态优先级是否大于当前正在运行的进程的优先级，如果是的话，那么当前运行中的进程被中断


# 时间片

在抢占式系统中，时间片的长短和系统响应时间没啥关系，因为当前运行的程序是可以被抢占的
但是非抢占式系统中，时间片越长，响应时间也就越长

1 基于nice值的优先级，nice值代表了分配给进程的时间片的长短
2 实时优先级，其实没懂实时优先级的实时具体代表什么


	CFS是把处理器的使用使用比划分给了进程 -> 进程所获得的处理器时间和负载密切相关

	nice值会影响进程使用处理器的时间比

	一个问题：cgroup是如何应用调度模块的来实现资源隔离的，如果仅仅是用到了nice值，那直接调nice值就可以了？


	时间片如何解决响应与吞吐的问题？
		分配处理器使用占比
		以文本编辑器和视频解码器的为例，文本编辑期望快速响应，视频解码器则重吞吐
		提升吞吐的方法：视频解码器一直运行
		提升响应的方法：当文本编辑器需要被运行时，可以主动抢断视频解码器的工作

		对比基于时间片的分配方式区别
			时间片的问题在于，不管文本编辑器任务是否实际需要运行，那么都是要拿出来跑一跑的

	数据库系统中是否有类似的问题？
		延迟敏感的查询和吞吐敏感的查询
		如果参考操作系统类似的设计，那么其实就是比较重的查询一直在跑，知道有轻量级的查询进来，才会主动中断

nice值直接映射到时间片的问题
	1 不够灵活，吞吐率上不去
	2 需要能够分配绝对的时间片，这个与定时节拍器有关
	3 nice值加减1，在不同的起始值的情况下，差别可能特别大

	绝对的时间片引发固定的切换频率，感觉上时间片最好不要和cpu的实际时间绑定

	CFS的意义：完全摒弃了时间片，而是分配给进程一个处理器的使用比重，可以保证恒定的公平性


问题1 ：linux的系统的调度算法是如何解决既要低延迟，又要高吞吐的？
问题2：linux如何区分批处理进程和交互式进程？（比如起了两个shell，一个做批处理，另一个等待用户输入，如何合理分配优先级）
	使用平均睡眠时间，公式如下
	bonus - 5 >= 静态优先级 / 4 - 28
	bonus - 5主要影响的是惩罚还是奖励的时间
	静态优先级越高的进程，越容易被看成是交互式进程

# 调度算法

swapper进程
	PID等于0，只有在cpu不能执行其他进程时才会被执行，感觉这就是个占位符进程
	其实就是idle进程

进程被调度的类型
	SCHED_FIFO，FIFO的实时进程，不受时间片的制约，不会被低优先级的抢断，想运行多久就运行多久
	SCHED_RR，相同优先级的实时进程公平的分配cpu时间
	SCHED_NORMAL，普通的分时进程

	实时进程和普通分时进程的区别是，实时进程不需要出让时间片给优先级更低的进程
	
## 优先级分类

静态优先级
	本质上决定了进程的基本时间片的大小，系统分配给进程时间片的长度，静态优先级越高，时间片就越长
	也就是可以跑多久

	还会影响系统的奖励和惩罚时间，主要来自于如下公式：
	bonus - 5 >= 静态优先级 / 4 - 28

动态优先级
	调度程序选择新进程来执行时使用的数值，影响调度选择决策的
	动态优先级越高的，越容易被调度系统调度

	公式如下：
	动态优先级 = max（100， min（静态优先级 - bonus + 5， 139））

	bonus依赖进程过去执行的情况（用进程的平均睡眠时间衡量），小于5表示降低动态优先级以示惩罚，大于5表示增加优先级以示奖励
	平均睡眠时间越长，则bonus越大

	可以得出的结论
	1 历史上睡眠时间长的，则会被调度系统更加高优选择
	2 静态优先级越高，那么值越小，那么动态优先级也就越高，是正相关的关系，可以获得的时间片也就越长
	3 静态优先级越高的进程，越容易被看成是交互式进程

## 如何避免进程饿死
即使优先级更高的进程需要拥有更长的时间片和更优先被调度，但是低优先级的进程也不该被饿死
为了避免饥饿的情况，linux维护两个进程集合

1 活动进程
	时间片没有被用完，所以需要被执行。进程用完了自己的时间片，就会被放入过期进程中

2 过期进程
	这些可运行进程用完了自己的时间片，因此禁止被运行，直到所有活动进程都过期

这块的主要思想是优先满足交互式进程被调度，同时对批处理进程进行兜底（不让他等待过长的时间）

## 实时进程的调度
与普通进程的重要区别
	实时进程禁止低优先级的进程运行

实时进程被其他进程取代的条件（满足一个即可）
	1 被更高优先级的实时进程抢占
	2 进程阻塞并进入睡眠状态
	3 进程停止或者被杀死
	4 主动yield放弃时间片
	5 基于时间片轮转的且放弃了时间片

## 调度程序使用的函数（这个是CFS算法吗？）

### scheduler_tick
	维持最新的时间片计数器
	这个函数的触发和时钟节拍相关

	概要流程
	1 检查当前是否有可执行的活动进程，有的话就更新时间该活动进程并检查是否执行完成，这个过程存在需要加锁的情况，主要是锁住cpu对应的队列
	2 如果没有活动进程，那么就需要发起一次调度

	根据进程的分类，时间片的更新可以分为以下几种情况
	1 FIFO实时进程，这种不会更新时间片，因为不会被优先级小于等于自己的抢占，也不会让出
	2 RR的实时进程，这种进程的时间片是要被更新的，如果耗尽了会被移动到run队列的尾部，并设置重新调度的标记位
	3 普通进程，也会做更新时间片，调整动态优先级，时间片耗尽时重新发起调度等操作，但同时会有以下区别
		该进程如果不是交互式进程会被直接放入过期队列
		如果是交互式进程，但是目前过期队列里有等待时间过长的进程，那么这个进程也会被放入过期队列，这是为了避免优先级低的进程被饿死
		是交互式进程，但是目前没有等待时间过程的进程，那么就会被放回活动队列

		如果当前进程的时间片未耗尽，那么会check剩余的时间片过长，过长的话也会被拆成若干个粒度
		这么做是为了避免具有高优先级的交互式进程长久的占有cpu

		动态优先级会被更新


### try_to_wake_up
	主要做的事情就是唤醒处于睡眠状态的进程，有几点需要注意的
	1 会有一个重新分配task位于哪个cpu的以达到负载均衡的目的，考虑的因素包括cpu是否空闲，是否可以利用cpu的本地缓存
	2 会看下新分配的进程是否可以抢占当前运行中的进程
	3 更新睡眠时间和动态优先级

### recalc_task_prio
	更新进程的平均睡眠时间和动态优先级

	把进程分成两种
	1 第一类，满足三个限定条件：非内核线程，从uninterruptible状态（不可中断模式）被唤醒，进程连续睡眠时间超过给定睡眠时间极限
		把平均睡眠时间设置为900个时钟节拍，这么做是期望从不可中断模式醒来的进程可以尽快的参与服务，同时又设置了平均睡眠时间的上限，避免引起其他进程的饥饿
	2 第二类，处于不可中断状态且不是内核线程
		正常情况sleep会累加到平均睡眠时间
		但是如果平均睡眠时间超过1000个时钟节拍，那么会重置为1000，也就是说平均睡眠时间的上限被锁死

	更新进程的动态优先级，平均睡眠时间通过影响bouns的值间接影响动态优先级的计算


	提出几个问题：
	都有哪些进程需要计算动态优先级？
		看起只有那些刚唤醒的，以及睡眠中的需要调整
		活动进程以及处于活动队列的进程似乎不需要？
		睡眠进程是用哪个数据结构保存的？


## CFS
设计理念，有n个进程时，每个进程能获得1/n的处理器时间
具体做法，允许每个进程运行一段时间，循环轮转，选择运行时间最少的进程作为下一个运行进程

公平公平公平，降低调度延迟带来的不公平性

与时间片的区别
	1 时间片的计算逻辑是固定的
	2 但是CFS策略里计算每个进程运行多久是根据当前进程数量确定的

Nice值对调度的影响
	nice不再对应绝对的时间片，而是结合其他进程的nice值，计算出一个cpu的使用比


组成部分
1 时间记账
	vruntime，进程的虚拟运行时间；初始值是系统当前时间减去上次开始执行时间，然后根据当前可运行进程总数对运行时间进行加权计算，最后累加到vruntime
	这个值由系统定时器周期性调用
	推测下所谓的加权计算做了啥，优先级高的可能会减小这个vruntime的值

2 进程选择，每次挑一个vruntime最小的去运行，使用的数据结构是红黑树
	红黑树中存的是系统重所有课运行的进程

	2.1 查找树，发生在寻找下一个可执行进程的时候
	2.2 加入树，新建一个进程或者唤醒一个进程为可执行状态
	2.3 删除树，阻塞或者结束执行时

3 调度器入口
	主要的方法在schedule()

	Why：为什么会有多个调度器，相互之间不会冲突吗？

	pick_next_task
		1 如果所有进程都在CFS里，那么就直接从CFS里取一个，否则执行第二步
		2 按照优先级遍历所有的调度器类，尝试从调度器类里取出一个task


4 睡眠和唤醒
	睡眠时会从红黑树移出，加入等待队列
	唤醒时则会写入红黑树

	和休眠相关的两种状态
	1 可以响应唤醒的，可以接收唤醒信号并从休眠中唤醒
	2 不可以响应唤醒的，会忽略一些唤醒信号
	两种状态的进程会位于等待队列上，等待某些事件，不能运行


	4.1 等待队列
		等待某些事件发生的进程组成的简单链表

		伪唤醒
			进程被唤醒是为了检查等待的事件是否就绪，如果没有就绪那么可能继续等待
			说明接受时间的触发是通过轮询感知的


5 抢占和上下文切换
	
	switch_mm，把虚拟内存从上一个进程映射到新进程中
	swtich_to，负责切换处理器和体系结构相关的信息

	need_resched标记位，表明需要重新调度一次（所谓的schedula意思是,按照优先级遍历当前的调度类，重新选一个可执行的进程出来），
		对内核来说意味着有其他进程应当被运行了

	用户抢占
	1 从系统调用返回用户空间时
	2 从中断处理程序返回用户空间时
	总之感觉就是要切回用户空间的时候就那啥了

	感觉用户进程可以被抢占的时机是系统调用发生的时候

	内核抢占
		内核发生的前提：调度是安全的（没有锁）就可以，没有锁的意思是代码是可重入的

		内核抢占运行中的线程
		内核抢占内核进程

		引入preempt_count计数来记录持有锁的个数，当这个值不为0，说明当前运行的进程代码持有锁。当为0，说明当前运行的进程没有持有锁，是可以被抢占的
			这个主要是针对用户进程而言，对于内核进程来说，抢占不需要额外的安全约束

		内核抢占的发生时机
		1 中断处理程序在返回内核空间之前
		2 内核代码再一次具有可抢占性
		3 内核中的任务显式调用schedule
		4 内核中的任务阻塞



## 实时调度策略
	
	FIFO，没有时间片的概念，优先级要比NORMAL高，一旦这个级别的进程开始运行，那么就会一直执行下午知道阻塞或者主动让出处理器

	软实时，尽力保证进程在它的限定时间到来前运行，但内核并不保证总能满足这些进程的需求

