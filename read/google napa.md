# Napa: Powering Scalable Data Warehousing with Robust Query Performance at Google

## 问题与背景
* 主要面向OLAP场景
* 数据量是行星尺度的大
* 亚秒级的查询响应
* 支持实时场景下的更新
* 用于替换MESSA
* 全球级别多数据中心的数据一致性保证(对于谷歌来说有很多现成的组件可以用，应该算是基本操作)

### 系统特色
* 查询性能的鲁棒性；依照文章中的说法，主要是通过物化视图实现，物化视图的覆盖度越高越容易做到；单纯依赖提升计算能力是比较困难的
* 灵活性；用户可以在查询性能，代价和数据新鲜度（可以理解为实时场景的导入延迟）之间做权衡
* 更新场景下的高吞吐摄入，主要通过异步延迟构建物化视图实现，当然物化视图之间是要保证一致性的

## 设计约束
* 在谷歌用户对系统的要求可以概括为三个方面，查询性能，实时数据延迟以及代价
* 由于谷歌的用户众多，对这三个方面的要求存在差异，比如某个用户对延迟敏感但是代价和性能不敏感
* 这个有点类似CAP理论，三个方面同时都要求最佳应该是做不到，只能是做取舍；主要特别注意的是，这里说的做取舍是指，系统开发者把做权衡的开关做好，用户根据需求自行进行取舍
* 举个例子
** 对于数据新鲜度不敏感的用户，可以选择把导入和物化视图的构建进行耦合
** 对于数据新鲜度很敏感的用户，可以选择延迟构建物化视图
** 如果一个用户既要求数据很新鲜，又要求查询延迟很低很稳定，那么可以做的是投入更多资源来做物化视图的构建和compaction，但也只能使得结果接近理想情况，无法达到最佳；因为以现有的技术实现，低查询延迟和低导入延迟本身就是矛盾的；

## 架构设计与实现
结合上文的设计约束，可以把系统拆成如下三个组件
* 数据导入系统
** 把增量写的数据（delta数据）提交到表中，满足最基本的持久化要求即可
* 存储系统
** 把delta数据更新到物化视图中；也负责做compaction工作
* 查询服务
** 响应客户端的sql查询请求，会做一些读时的delta merge操作;

### 如何为客户端提供灵活性
* 用户通常理解的查询性能，数据新鲜度以及代价可以直接转换成数据库配置，比如物化视图的个数，各种离线task的数量以及以及读数据时的delta文件的数量
* Queryable Timestamp(QT)，主要指明了数据新鲜度（now - QT），关于QT的一些基本规则如下
** 只有时间戳小于QT的数据可以查询的
** QT可以增长的条件是，给定数量的物化视图构建完成并且delta文件的个数不超过配置
** QT稳定增长可以认为在当前的数据库配置下（比如n个物化视图，m个delta），用户对查询的各项要求是可以满足的；
* 举个例子
** 某个用户希望数据的新鲜度和查询性能都很好，同时可以付出更高的代价；
** 这意味这个表需要维护很多的物化视图以及保证查询时有很少的delta文件同时满足时，QT的值才可以增长
** 对于NAPA来说，需要启动大量的compaction以及构建物化视图的Task才能同时保证查询时的性能以及鲁棒性

### 数据的可用性
* 支持全球多数据中心的数据一致性
* 这里的创新之处，先保证单数据中心内的数据一致性，完成所谓的数据操作；多个数据中心之间的数据一致性是批量的异步操作完成的

### 来一张架构图
* 用的是谷歌自己的分布式文件系统
* 用Spanner提供严格的事务语义（类似Doris的FE）
* 使用F1 Query完成查询服务以及视图创建的服务，F1 Query同时支持流式处理和批处理的场景

## 一些模块细节

### 数据导入模块
* 和视图维护模块是解耦的，主要保证的是数据的持久化
* 提供了资源控制的按钮，这里的资源控制主要说的是对接收数据，执行导入聚合以及数据复制的task数目进行动态调控的能力

### 关于QT
* 其实就是用于衡量数据导入延迟的
* NAPA认为查询时open和merge的delta问你件数量是非常影响查询性能的，如果想提升查询的性能，那么应该尽可能减少查询时的dela文件的数量
* 因此会有一个自动的模块根据表的查询负载对delta文件的数量进行限制，查询负载越高的场景，预期的delta文件数是越少的
（这里有几个问题，查询负载如何衡量，如何动态调节）
* NAPA中QT的保证是非常依赖compaction和物化视图的
* QT也可以用于指明数据一致性，包括本地副本，机房内，跨机房
* 对应于doris中version的概念，一个version只commit但是不publish是不可见的；只有publish之后才是可见的

### 维护大规模的视图
* 用F1 Query完成compaction和视图的维护
* 会对数据倾斜的情况进行检测并优化
* 只能检测长尾的物化视图；为了保证物化视图的一致性，物化视图的更新速度主要会受制于更新最慢的那个，NAPA会对这种情况进行检测并尝试调度更多资源对这种情况进行解决

#### 视图的查询优化挑战
* 充分利用数据属性进行处理
* 例如
** 物化视图和base表的key列顺序完全相同，那么在构建物化视图的时候是可以避免排序操作的
** key列部分顺序相同

## 对比Doris现状
### 设计角度

和Doris做一个对比的话，doris是把数据的查询，存储和物化视图构建以及compaction都放到一个BE进程中了，目前看在用户和数据达到一定规模的情况下，这是一种十分失败的设计
NAPA是在设计时对各个模块做了解耦，然后根据用户需要在实际使用时根据需要进行耦合
这个就是NAPA所谓的灵活性，个人认为这也是NAPA这个系统最优秀的地方，把系统设计中两难的点转换成业务可以理解的指标，然后抛给用户，让用户根据场景自行选择

NAPA有弹性设计，个性化配置

当用于导入延迟或者查询延迟时，第一反应是怀疑系统挂了

### 架构角度
NAPA是完全结构解耦的，而doris是完全耦合的