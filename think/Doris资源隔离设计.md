# 首先需要定义使用场景
Q：为什么要做资源隔离？
A：当用户的对资源的用量永远不超过集群上限时，那么其实不需要做资源隔离
	但是线上一定会出现查询负载超过物理资源上限的情况，此时我们期望系统依然能够对部分查询的稳定性做出保证，使得整个系统依然呈现出可用状态

Q：Doris的资源隔离从用户视角长什么样？
A：用户需要对自己的业务场景有一定理解，指的是能够根据优先级/负载的维度对查询进行划分
	
	用户可以得到的系统侧的承诺：
	1 只要用量没有超过资源组上限，那么查询延迟可以符合预期
	2 如果用量超过资源组上限，查询延迟会变高或者由于超过用户预期的时间而失败
	3 不同资源组之间不会相互影响
	4 系统资源使用情况需要可观测，用户需要掌握当前资源组配合和实际用量，从而做出合理的决策

	简单来说目前Doris能够实现类似yarn队列调度的用户体验即可

用户使用流程：
	用户根据业务场景划分资源组 -》 用户提交不同查询到划分好的不同资源组 -》当某个资源组查询延迟上升查看监控 -》 用户根据监控确认当前资源量超过上限然后做出决策（1，限流；2 对该资源组加资源；3 接受延迟上升）

核心理念
	完整的使用体验，对于延迟增加的问题要能够解释
	用户能够理解优先级并对业务做一个区分，引擎能够提供隔离的能力，这个承诺是，查询负载上升时，各个资源组之间不会相互影响，资源组内查询延迟会稳定上升，但不会都查不出来或者直接挂掉

从具体的业务使用场景出发
	划分场景
	1 3秒以内交互式的
	2 异步adhoc查询/定时任务

# 需要解决的实际的一些场景举例
需要设计各种测试用例
如果刚进来的查询很多，都集中在第一级队列中，那么如何保证低优先级队列的任务可以被执行
不同task的调度时间差异很大怎么办，比如同样是聚合算子，有的是bitmap，有的是sum的

做数据库的查询调度器，需要考虑哪些维度
	支持优先级
	负载的类型
		重CPU，轻CPU
		重IO，轻IO
		重内存，轻内存

	目前主要解决cpu的问题

需要深度思考的问题
1 调度周期意味着什么
2 具体实现时要考虑的问题
	单核与多核
	任务实际执行的时间可能不是对称的，同样的调度次数占用的时间片可能是不同的
3 考虑cpu cache的亲和性
4 响应时间和周转时间
	响应时间是什么？，首次运行时间-到达时间
		在现在操作系统中，主要是想解决交互式应用的响应问题，但其实从数据库的角度来说，是没有交互式的查询的
		关心的是啥最早可以开始工作是啥时候
		主要是采用轮转的方式解决
	周转时间是什么？感觉上想衡量的是调度的等待时间
		完成时间 - 到达时间，是一个性能指标
			其实就是包含了执行时间和调度的时间的
				最短任务优先,先跑短任务，再跑长任务，周转时间下降。但问题是如果先来了长任务，
				和最短完成时间优先，优化周转时间，需要支持抢占式执行，也就是每次来了新任务都得推算下实际执行的时间

	优化周转时间，也就是关注任务的结束时间，最短任务，最短完成时间优先的设计是比较好的
	优化响应时间，时间片轮转

	多级反馈队列，优化周转时间，同时降低响应时间


5 IO这块如何处理

# 方案设计

核心算法
1 多级反馈队列
	设计目标，同时兼顾响应时间和周转时间
	规则：
	有许多独立的队列，每个队列有不同的优先级
	1 如果A的优先级大于B的优先级，运行A
	2 如果A，B的优先级相同，那么就轮转A，B
		（上述两条保证了，优先级高的任务可以先被执行，但是低优先级的任务可能被饿死）
	3 新进入的job放到最高优先级
	4 一旦某个工作用完了某一层的配额，就会被移动到下一层的队列
		（3,4看起来实现了优先级的调整，短任务可以被先执行，但是低优先级的任务依然会被饿死）
	5 经过一段时间的运行，就把系统中所有job重新加入最高优先级队列

2 比例份额
	关键问题：如何按比例分配cpu

## 思路之调度系统
	需要能够支持隔离

	资源组如何实现单机内时间片的，这个是由用户配置的
		一个红黑树，key是占用的cpu的时间，每次找最小的，不同队列的优先级区别是体现在时间片增长的差异（这块需要细化下算法逻辑，为啥这么做可以保证时间片的占比）

	资源组内部如何设计，暂时我们只以cpu时间为维度做划分，低cpu的查询可以快速跑完。高cpu的查询不会饿死
		要不要做优先级，所有查询纯公平调度，还是做一些区分度
		可以区分高cpu查询和低cpu查询
		可以通过多级反馈队列来做

		这里还有个问题是，要不要做sql粒度的优先级划分

## 调度系统算法流程

组件抽象
	一个调度器
		负责选择下次要执行的资源组
		负责把资源组内下次要执行的任务选出来然后进行支持


	资源组队列，主要用于实现时间片的分配
	组内的多级反馈队列，主要用于实现小查询(业务可以感知的)快速响应，大查询(业务异步跑的)不被饿死
		这里其实还有一个问题，小查询又可以有两重理解（1，本身cpu时间就比较低的； 2 cpu时间高，但是由于机器多并发高，可能就可以很快执行完的）

	流程概要
		当cpu出现空闲的时候，此时调度器先选下一个可以执行的资源组
		然后从资源组内部选一个可以执行的task，把这个task提交给cpu执行

算法流程
1 一个查询会先被拆成多个task
2 根据一定的规则选择资源组，把task放入资源组内部的队列中
3 当调度器发现有空闲的worker时，就会先选择接下来需要执行的资源组
	选此时占用的cpu时间最少的资源组（这里的细节是，这个计算cpu时间的方法是啥，执行同样的时间，但是需要除以或者乘以不同的比例）
4 资源组从多级反馈队列里，取一个task出来
	这里是先选一个队列，然后取队列头部的task
	选队列的逻辑是，现在的思路是
		选一个时间最短的，但是其实不同队列cpu时间的增长系数是不同的
	
5 当这个task被执行完成，需要写回多级反馈队列
	记录task的累计执行时间
	如果超出目前队列允许的累计时间范围，那么就把他往下一级调
	否则，就放入目前优先级队列的尾部	




# 如何做测试
每次PR如何做回归，保证性能不回退
调度系统的性能如何衡量




